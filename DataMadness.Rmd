---
title: "Data Madness"
author: "Martin Gassner, Henry Mauranen"
date: "17 March 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
  knitr::opts_chunk$set(
  fig.path = "images/"
)
```


```{r libraries, message=FALSE, warning=FALSE, error=FALSE}
library(Rmisc) # Necessarely before dplyr
library(dplyr)
library(ggplot2)
library(car)
library(klaR)
library(mclust)
library(stringr)
library(cluster)
library( mice )
library( reshape2 )
library(grDevices)
library( gridExtra )
library( doBy )
```

## Introduction



```{r data_import}
load("./measuringMoralityDuke/MMdata_merged.rdata")
personalColumns <- colnames(MMdata_merged)[255:278]

MMdata_merged[is.na(MMdata_merged)] <- -1

# Leaving out single valued questions, because they can be grouped when constructing the blocks later on
questionIds <- c("C","I","RFQ","REI","MR","EPQ","L","DPES","SP","DIT","RAND_DIT","MELS","MOPS","Dov_mops","MFSS","MI","CQR","IS","SV","TET","EVA")

patternIds <- function( names, pat ) names[ !is.na( str_extract( names, pat ) ) ]

regexes <- sapply(questionIds, function(x){
  paste0("^",x,"[0-9]+(_[A-Z])?$")
  })

questionIdNames <- sapply(regexes, function(x) {
  patternIds(colnames(MMdata_merged), x)
})

block1 <- questionIdNames$C
block2 <- c(questionIdNames$I, questionIdNames$RFQ)
block3 <- questionIdNames$REI
block4 <- c(questionIdNames$MR, questionIdNames$EPQ)
block5 <- questionIdNames$L
block6 <- questionIdNames$DPES
block7 <- c(questionIdNames$DIT, questionIdNames$RAND_DIT)
block8 <- c(questionIdNames$MELS, questionIdNames$MOPS)
block9 <- questionIdNames$MFSS
block10 <- questionIdNames$MI
block11 <- questionIdNames$CQR
block12 <- questionIdNames$IS
block13 <- questionIdNames$SV
block14 <- questionIdNames$TET
block15 <- "Block15"
block16 <- questionIdNames$EVA
block17 <- "Dov_game"

blocks <- list(block1,block2,block3,block4,block5,block6,block7,block8,block9,block10,block11,block12,block13,block14,block15,block16,block17)
```

```{r clustering, warning=FALSE}
# Suppressing warnings because Loess causes problems with spms

# This block is commented out, because it should not be run as one. Commands are heavy and produce a lot of output. Choose which plots and cluster you want to examine before running commands.

#mclusters <- lapply(blocks, function (x) {
#Mclust(MMdata_merged[x])
#})

# fullCluster <- Mclust(MMdata.imputed[unlist(blocks)])

# Printing all summaires for all clusters
#lapply(mclusters, summary, parameters=TRUE)

# Ignoring 15 and 17, since there's only one question
#clusterBlocks <- blocks[-c(15,17)]
# spm generation for inside the blocks
#lapply(clusterBlocks, function(x){
#  columns <- paste0("~", paste(x, collapse = "+"))
#  spm(as.formula(columns), MMdata_merged)
#})
```


To obtain a weighting for each block of questions

1. obtain the principal components for each block

2. keep the ones explaining 85% of the variance

3. for each variable: sum the loadings of the most important principal components, 
weighted by the variance explained.

Additionally we tested the weights for significance within each block.

```{r principal_component_analysis}
MMdata_merged.zerofill <- MMdata_merged
MMdata_merged.zerofill[ is.na( MMdata_merged ) ] <- 0
MMdata_merged.zerofill[ MMdata_merged.zerofill == -1 ] <- 0
blocks.pcs <- lapply( blocks, function( b ) princomp( MMdata_merged.zerofill[ b ] ) )

# compute weights from pc
weightsFromPc <- function( t, pc ) 
  {
    parvs <- pc$sdev / sum( pc$sdev )
    cumvs <- cumsum( parvs )
    sigCs <- cumvs < t
    if( length( parvs[ sigCs ] ) > 1 )
      return( apply( abs( parvs[ sigCs ] * pc$loadings[ ,sigCs ] ), 1, sum) )
    else
      return( sum( pc$loadings) )
  }
blocks.weights.raw <- sapply( blocks.pcs, function( pc ) weightsFromPc( 0.85, pc ) )
blocks.weights.norm <- sapply( blocks.weights.raw, function( ws ) ws / sum( ws ) )

# test weights for significance for normal or uniform distributions
# H0: data is normal
testNorm <- function( xs ) if( length( xs ) > 2 ) shapiro.test( xs )$p.value else 0
# H0: data is uniform
testUnif <- function( xs ) ks.test( xs, "punif" )$p.value
# p value of x given that xs if normally distributed
normSig <- function( x, xs ) pnorm( x, mean=mean( xs ), sd=sd( xs ) )
# p value given that x is uniformly distributed
unifSig <- function( x, xs ) x / ( max( xs ) - min( xs ) )
# test whether p lies outside center 1-alpha prob region
twoSideP <- function( alpha, p ) p >= 0 && (p < alpha / 2 || p > 1 - alpha / 2)

alpha <- 0.1

blocks.weights.norm.pnorm <- sapply( blocks.weights.norm, testNorm )
blocks.weights.norm.punif <- sapply( blocks.weights.norm, testUnif )

blocks.weights.norm.sig <- sapply( blocks.weights.norm, function( ws ) replicate( length( ws ), -1 ) )
blocks.weights.norm.sig[ blocks.weights.norm.pnorm > 1 - alpha ] <- sapply( 
  blocks.weights.norm[ blocks.weights.norm.pnorm > 1 - alpha ]
  , function( xs ) sapply( xs, function( x ) normSig( x, xs ) )
  )

blocks.weights.norm.df <- as.data.frame( melt( blocks.weights.norm ) )
blocks.weights.norm.df$name <- unlist( blocks )
blocks.weights.norm.df$sig <- sapply( melt( blocks.weights.norm.sig )$value
                                      , function( pval ) twoSideP( alpha=alpha, pval ) )
ggplot( blocks.weights.norm.df[ blocks.weights.norm.df$L1 != c(15, 17), ]
        , aes( x=name, y=value, color=sig ) ) + 
  geom_col() + 
  facet_wrap( ~L1, ncol=4, scales="free" ) +
  theme( axis.text.x=element_text( angle=45, hjust=1 ) )
```


```{r pca_cmp_threshold}
blocks.altweights.raw <- sapply( blocks.pcs, function( pc ) weightsFromPc( 0.50, pc ) )
blocks.altweights.norm <- sapply( blocks.weights.raw, function( ws ) ws / sum( ws ) )

blocks.altweights.norm.pnorm <- sapply( blocks.altweights.norm, testNorm )
blocks.altweights.norm.punif <- sapply( blocks.altweights.norm, testUnif )

blocks.altweights.norm.sig <- sapply( blocks.altweights.norm, function( ws ) replicate( length( ws ), -1 ) )
blocks.altweights.norm.sig[ blocks.altweights.norm.pnorm > 1 - alpha ] <- sapply( 
  blocks.altweights.norm[ blocks.altweights.norm.pnorm > 1 - alpha ]
  , function( xs ) sapply( xs, function( x ) normSig( x, xs ) )
  )

blocks.altweights.norm.df <- as.data.frame( melt( blocks.weights.norm ) )
blocks.altweights.norm.df$name <- unlist( blocks )
blocks.altweights.norm.df$sig <- sapply( melt( blocks.altweights.norm.sig )$value
                                      , function( pval ) twoSideP( alpha=alpha, pval ) )

ggplot( blocks.weights.norm.df[ blocks.weights.norm.df$L1 != c(15, 17), ]
        , aes( x=name, y=value, color=sig ) ) + 
  geom_col() + 
  facet_wrap( ~L1, ncol=4, scales="free" ) +
  theme( axis.text.x=element_text( angle=45, hjust=1 ) )
```


```{r transforming_blocks}
# just do matrix multiply: original dims x reduced dims
blockTransform <- matrix( data=0, nrow=length( unlist( blocks ) ), ncol=length( blocks ) )
for( ib in 1:length( blocks ) )
{
  off <- if( ib > 1 ) sum( sapply( blocks, length )[ 1:(ib - 1) ] ) else 0
  blockTransform[ (off + 1):(off + length( blocks[[ ib ]] ) ), ib ] <- blocks.weights.norm[[ ib ]]
}
```


```{r clustering_transformed_blocks}
MMdata.blockt <- as.matrix( MMdata_merged[ ,unlist( blocks ) ] ) %*% blockTransform
MMdata.blockt.kclusters <- lapply( 2:20, function( k ) kmeans( MMdata.blockt
                                                               , centers=unique( MMdata.blockt )[ 1:k, ]
                                                               , iter.max=100 )  )

weightedIntradiff <- function( k ) sum( k$withinss * k$size )
plot( sapply( MMdata.blockt.kclusters, weightedIntradiff )
      , xlab="number of clusters"
      , ylab="weighted intraclass difference" 
      , main="difference per cluster size")

diff1d2pt <- function( xl, xm, h ) (xl - xm) / h
diff2d3pt <- function( xl, xm, xr, h ) (xl - 2*xm + xr) / h^2
```

```{r clustering_transformed_sizes}
transformClusterSize <- 5
MMdata.blockt.clustered <- data.frame( cbind( MMdata.blockt
                                              , factor( MMdata.blockt.kclusters[[ transformClusterSize - 1 ]]$cluster ) ) )
colnames( MMdata.blockt.clustered ) <- c( paste0( "block", 1:length( blocks ) ), "cluster" )

# use this if NOT knitting
# MMdata.blockt.clustered.counts <- data.frame( count( MMdata.blockt.clustered$cluster ) )
# use this if knitting
MMdata.blockt.clustered.counts <- data.frame( count( MMdata.blockt.clustered, cluster ) )

#ggplot( MMdata.blockt.clustered.counts
#        , aes( x=x, y=freq ) ) + geom_col() +
#  xlab( "cluster" ) + ylab( "size" ) + ggtitle( "cluster sizes" )
```


```{r clustering_transformed}


ggplot( melt( MMdata.blockt.clustered, id.vars="cluster")
        , aes( group=cluster, x=cluster, y=value ) ) + 
  geom_boxplot() + 
  facet_wrap( ~variable, scales="free_y" ) +
  ggtitle( "distribution of responses" )
```


```{r transformed_cluster_lines}
MMdata.blockt.clustered.rawmeans <- lapplyBy( ~cluster
                                              , data=MMdata.blockt.clustered
                                              , FUN=colMeans )
MMdata.blockt.clustered.means <- melt( matrix( unlist( 
  MMdata.blockt.clustered.rawmeans[ order( names( MMdata.blockt.clustered.rawmeans ) ) ] )
  , ncol=length( MMdata.blockt.clustered.rawmeans ) ) )
colnames( MMdata.blockt.clustered.means ) <- c( "block", "cluster", "mean" )
MMdata.blockt.clustered.means$cluster <- factor( MMdata.blockt.clustered.means$cluster )
ggplot( MMdata.blockt.clustered.means
        , aes( x=block, y=mean, color=cluster ) ) +
  geom_line() +
  xlab( "question block" ) + ylab( "mean response" ) +
  ggtitle( "Overview of mean responses" )
```

big differences
Block 2: Identity measures - clusters 2,5 (less important) vs. 1,3 (very important)

highly weighted: job, political party, favorite sports team

Block 4: Moral relativism - cluster 2 (relative) vs 5 (disagreeing)

higly weighted: What is right and wrong is up to each person to decide

Block 9: Sacredness of moral principles - cluster 1 (less) vs 2,3,5 (more)

higly weighted: Sign a piece of paper that says “I hereby sell my soul, after my death, to whoever has
this piece of paper” (SIGNIFICANT)

low weighted: Attend a performance art piece in which all participants (including you) have to act
like animals for 30 minutes, including crawling around naked and urinating on stage

Block 17: all different; rank 1, 2, 3, 4, 5

```{r transformed_cluster_significance}
print( "Block 2: Identity measures - clusters 2,5 (less important) vs. 1,3 (very important)" )
t.test( MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(2,5) ) ]
        , MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(1,3) ) ] )$p.value

print( "Block 4: Moral relativism - cluster 2 (relative) vs 5 (disagreeing)" )
t.test( MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(2) ) ]
        , MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(5) ) ] )$p.value

print( "Block 9: Sacredness of moral principles - cluster 1 (less) vs 2,3,5 (more)" )
t.test( MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(1) ) ]
        , MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(2,3,5) ) ] )$p.value

print("Block 17: Dictator game - cluster 1 vs 2, 3, 4, 5")
t.test( MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(1) ) ]
        , MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(2,3,4,5) ) ] )$p.value

print("Block 17: Dictator game - cluster 2 vs 1, 3, 4, 5")
t.test( MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(2) ) ]
        , MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(1,3,4,5) ) ] )$p.value

print("Block 17: Dictator game - cluster 3 vs 1, 2, 4, 5")
t.test( MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(3) ) ]
        , MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(1,2,4,5) ) ] )$p.value

print("Block 17: Dictator game - cluster 4 vs 1, 2, 3, 5")
t.test( MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(4) ) ]
        , MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(1,2,3,5) ) ] )$p.value

print("Block 17: Dictator game - cluster 5 vs 1, 2, 3, 4")
t.test( MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(5) ) ]
        , MMdata.blockt.clustered$block4[ is.element( MMdata.blockt.clustered$cluster, c(1,2,3,4) ) ] )$p.value

```

Cluster 1

- find many things (country, religion etc) relevant to their identity

- do not hold moral values high/more pragmatic

- give the least in the dictator game

Cluster 2

- find less things relevant to their identity

- moral relativists

- do think of their moral values sacred/would take a lot of money

- second to last in dictator game

Cluster 3

- average, really everywhere

Cluster 4 

- irrelevant, too small, collects refused answers

Cluster 5

- find less things relevant to their identity

- oppose moral relativism

- do hold their morals dear

- give the most in the dictator game (exactly average)

```{r clustering_transformed_personal}
# means of personal variables
MMdata.merged.clustered <- cbind( MMdata_merged, MMdata.blockt.clustered$cluster )
colnames( MMdata.merged.clustered ) <- c( colnames( MMdata_merged) , "cluster" )

# MMdata.merged.clustered %>% group_by( cluster ) %>% summarise_at( vars( ppeduc, ppage, ppgender, ppethm, ppincimp, ppnet ), funs( mean( ., na.rm=TRUE)))

MMdata.merged.clustered$ppgender <- factor( MMdata.merged.clustered$ppgender
                                            , labels=c("male", "female" ) )
MMdata.merged.clustered$ppeducat <- factor( MMdata.merged.clustered$ppeducat
                                            , labels=c( "none", "high school", "college", "Bachelors+") )
MMdata.merged.clustered$ppethm <- factor( MMdata.merged.clustered$ppethm
                                          , labels=c( "white", "black", "other", "hispanic", "2+" ) )
#MMdata.merged.clustered$ppincimp <- factor( MMdata.merged.clustered$ppincimp
#                                            , labels=c("< 10k", "10-25k", "25-50k", "50-75k", "75k+" ) )
MMdata.merged.clustered$ppnet <- factor( MMdata.merged.clustered$ppnet
                                         , labels=c( "yes", "no" ) )
MMdata.merged.clustered$ppagect4 <- factor( MMdata.merged.clustered$ppagect4
                                            , labels=c( "18 - 29", "30 - 44", "45 - 59", "60+") )
MMdata.merged.clustered$ppmarit <- factor( MMdata.merged.clustered$ppmarit
                                           , labels=c( "married", "widowed", "divorced", "separated", "never married", "with partner" ) )
MMdata.merged.clustered$pphouse <- factor( MMdata.merged.clustered$pphouse
                                           , labels=c( "house det", "house att", "appartment", "mob home", "other" ) )

pvars.plots <- lapply( c( "ppagect4", "ppeducat", "ppgender", "ppethm", "ppnet", "ppmarit", "pphouse" )
                       , function( v ) ggplot( data=MMdata.merged.clustered
                                               , aes_string( x="cluster", fill=v ) ) +
                         geom_bar( position="fill" ) )

#for( plot in pvars.plots ) plot
grid.arrange( grobs=pvars.plots[ 1:4 ] )
grid.arrange( grobs=pvars.plots[ 5:7 ], ncol=2 ) 

```


```{r kmodes_methods}
# Define methods for the clusters

get_tot_diffs <- function(x, max_size=15) {
  # Get the maximum difference for 15 different cluster sizes (from 2 to 16)
  kmode_res <- lapply(1:max_size, function(i){kmodes(x, i+1)})
  diffs <- lapply(kmode_res, function(y){sum(y$withindiff)})
  return(unlist(diffs))
}

test_kmodes_runs <- function(x, tests=5, max_size=15) {
  # Runs the get_max_diffs function different times to average out the random initial seed of kmodes
  all_tests <- lapply(1:tests, function(y) {get_tot_diffs(x, max_size)})
  
  # Returns dataframe with runs as rows and cluster number as columns (V[number of clusters - 1])
  return(as.data.frame(do.call(rbind, all_tests)))
}

avg_diffs_for_block <- function(x, tests = 20, max_size=15) {
  # Averages the cluster scores given by the previous method
  run_for_block <- test_kmodes_runs(x, tests = tests, max_size = max_size)
  print('Finished testing for one block')
  return(sapply(names(run_for_block), function(y) {mean(run_for_block[,y])}))
}
```

```{r kmodes_on_blocks_init}
multi.dim.idx <- c(1:14,16)
multi.dim.blocks <- blocks[multi.dim.idx]
```

```{r kmodes_on_blocks, eval=FALSE, echo=FALSE}
# WARNING: VERY LONG COMPUTATION! NOT WORTH RUNNING
# The results are in the object n_clust (2 blocks below)
# Actual computation of average intr-cluster difference for different k with kmodes 
all_avgs <- vector('list', length(multi.dim.blocks))
for (i in 1:length(multi.dim.blocks)){
  print(paste0(c('Iteration ', i), collapse = ''))
  
  all_avgs[[i]] <- avg_diffs_for_block(MMdata_merged[,multi.dim.blocks[[i]]], tests = 8)
}
```

```{r print_kmodes, eval=FALSE, echo=FALSE}
for (i in c(1:11,13,14,16)){
  print(paste0(c('Block ', i), collapse=''))
  plot(all_avgs[[i]])
}
```

```{r create_clusters}
# For block 2, 13 and 16 no proper value
# Same order as multi dim blocks
n_clust <- c(6, 4, 5, 6, 5, 6, 7, 7, 6, 6, 7, 8, 5, 8, 9)
clust_obj <- vector('list', length(n_clust))

# Get the cluster objects for each block
for (i in 1:length(multi.dim.blocks)){
  data <- MMdata_merged[,multi.dim.blocks[[i]]]
  clust_obj[[i]] <- kmodes(data, distinct(data[1:n_clust[i],]))
}
all_var_kmodes_6 <- kmodes(MMdata_merged[, unlist(blocks)], distinct(MMdata_merged[1:6,unlist(blocks)]))
all_var_kmodes_9 <- kmodes(MMdata_merged[, unlist(blocks)], distinct(MMdata_merged[1:9,unlist(blocks)]))
all_var_kmodes_11 <- kmodes(MMdata_merged[, unlist(blocks)], distinct(MMdata_merged[1:11,unlist(blocks)]))

clust_df <- data.frame(block1=clust_obj[[1]]$cluster)
for (i in 2:length(multi.dim.blocks)){
  clust_df <- cbind(clust_df, clust_obj[[i]]$cluster)
}
colnames(clust_df) <- paste0('block',multi.dim.idx)

clust_df$all.blocks.6 <- all_var_kmodes_6$cluster
clust_df$all.blocks.9 <- all_var_kmodes_9$cluster
clust_df$all.blocks.11 <- all_var_kmodes_11$cluster
```

```{r, clust_transition_function}
# E.g. create.intersect.df('block1', 'block12', clust_df)
# Given names of 2 columns as string (e.g. block names), a dataframe with cluster values, create heatplot and return matrix
create.intersect.df <- function(x_name,y_name,data,norm_first=TRUE, return_mat=FALSE){
  idx <- data[,x_name]
  idy <- data[,y_name]
  
  # Get the clusters
  clust_x <- lapply(1:max(idx), function(i) which(idx == i))
  clust_y <- lapply(1:max(idy), function(i) which(idy == i))
  
  # Create the matrix with transitions
  mat.res <- lapply(clust_x, function(i) lapply(clust_y, function(j)length(intersect(i,j))))
  mat.res <- t(matrix(unlist(mat.res), nrow = max(idy), ncol = max(idx)))
  
  if (norm_first==TRUE) {
    mat.res <- t(apply(mat.res, 1, function(x) x/sum(x)))
  }
    
  p <- ggplot(melt(mat.res), aes(x=Var1, y=Var2, fill=value)) + geom_tile() + labs(fill='Intersecting', x=paste0(c('from', x_name), collapse = ' '), y=paste0(c('to', y_name), collapse = ' ')) + ggtitle(paste0(c('Transitions from', x_name, 'to', y_name), collapse = ' ')) + geom_text(aes(label=round(value, 3)))
  
  if (return_mat)
    return(mat.res)
  
  return(p)
}
```

```{r transition_graph_list}
block.names <- c("block1", "block2", "block3", "block4", "block5", "block6", "block7", "block8", "block9", "block10", "block11", "block12", "block13", "block14", "block16", 'all.blocks.6', 'all.blocks.9', 'all.blocks.11')

# The list with all transition graphs
graph_list <- vector('list', length(block.names)^2 - length(block.names))
mat_list <- vector('list', length(block.names)^2 - length(block.names))

count <- 1
for (i in 1:length(block.names)){
  for (j in 1:length(block.names)){
    name_1 <- block.names[i]
    name_2 <- block.names[j]
    # Don't get useless identity graphs
    if (name_1 != name_2) {
      graph_list[[count]] <- create.intersect.df(name_1, name_2, clust_df)
      mat_list[[count]] <- create.intersect.df(name_1, name_2, clust_df, norm_first = FALSE, return_mat = TRUE)
      count <- count + 1
    }
  }
}

```

```{r}
plot.clust.distr <- function(clust_name){
  vars <- c('ppagect4', 'ppeducat', 'ppgender', 'ppethm')
  
  agecat <- c('18-29', '30-44', '45-59', '60+')
  educat <- c('<HS', 'HS', 'Cg', 'Bsc')
  gencat <- c('M', 'F')
  ethcat <- c('White', 'Black', 'Other', '2 or more', 'Hispanic')
  
  categories <- list(agecat, educat, gencat, ethcat)
  
  comparison_df <- clust_df
  
  for (i in 1:length(vars)){
    var <- vars[i]
    comparison_df[[var]] <- categories[[i]][MMdata_merged[, var]]
  }
  
  return(multiplot(plotlist=lapply(vars, function(var) ggplot(data=comparison_df, aes_string(x=clust_name, fill=var)) + geom_bar(position='fill')), cols = 2))
}
```


```{r between_clust_analisys}


print("Interesting transition from block6(2) to block13(3), from block16(2) [The 'hippies' (all 7 in block6)]")
p_1 <- create.intersect.df('block6', 'block13', clust_df, norm_first = FALSE)
p_2 <- create.intersect.df('block13', 'block16', clust_df, norm_first = FALSE)
p_3 <- create.intersect.df('block6', 'block16', clust_df, norm_first = FALSE)
multiplot(p_1, p_2, p_3, cols = 2)

print("Plotting only block 6 info [check cluster 2]")
plot.clust.distr('block6')

print("Interesting transition from block5(5) to block4(5), block12(5) to block4(5), block10(5) to block4(5) [Still undecided]")
g_1 <- create.intersect.df('block5', 'block4', clust_df, norm_first = FALSE)
g_2 <- create.intersect.df('block12', 'block4', clust_df, norm_first = FALSE)
g_3 <- create.intersect.df('block10', 'block4', clust_df, norm_first = FALSE)
multiplot(g_1, g_2, g_3, cols = 2)

print("Plotting only block 5 info [check cluster 5]")
plot.clust.distr('block5')

print("Interesting transition between block4(1), block12(1) [The 'Believe in Jesus but don't like the word religious'] [about 180 people in both cluster]")
create.intersect.df('block4', 'block12', clust_df, norm_first = FALSE)

print("Plotting only block 4 info [check cluster 1]")
plot.clust.distr('block4')

print("Interesting transition from block16(2) and block2(2) [The non religious] [about 275 people in both clusters]")
create.intersect.df('block16', 'block2', clust_df, norm_first = FALSE)

print("Plotting only block 16 info [check cluster 2]")
plot.clust.distr('block16')

print("Interesting transition between block16(3) and block12(1) [High integrity and moral values (christians)] [about 270 people]")
create.intersect.df('block16', 'block12', clust_df, norm_first = FALSE)

print("Plotting only block 12 info [check cluster 6]")
plot.clust.distr('block12')

print("Clusters in all.blocks.6 => {6: [Non religious], 4: [Hippies/High integrity and moral], 1: [Always undecided], }")
plot.clust.distr('all.blocks.6')
```

