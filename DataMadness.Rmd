---
title: "Data Madness"
author: "Martin Gassner, Henry Mauranen"
date: "17 March 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
  knitr::opts_chunk$set(
  fig.path = "images/"
)
```


```{r libraries, message=FALSE, warning=FALSE, error=FALSE}
library(dplyr)
library(ggplot2)
library(car)
library(klaR)
library(mclust)
library(stringr)
library(cluster)
library( mice )
library( reshape2 )
library(grDevices)
```

## Introduction



```{r data_import}
load("./measuringMoralityDuke/MMdata_merged.rdata")
personalColumns <- colnames(MMdata_merged)[255:278]

MMdata_merged[is.na(MMdata_merged)] <- -1

# Leaving out single valued questions, because they can be grouped when constructing the blocks later on
questionIds <- c("C","I","RFQ","REI","MR","EPQ","L","DPES","SP","DIT","RAND_DIT","MELS","MOPS","Dov_mops","MFSS","MI","CQR","IS","SV","TET","EVA")

patternIds <- function( names, pat ) names[ !is.na( str_extract( names, pat ) ) ]

regexes <- sapply(questionIds, function(x){
  paste0("^",x,"[0-9]+(_[A-Z])?$")
  })

questionIdNames <- sapply(regexes, function(x) {
  patternIds(colnames(MMdata_merged), x)
})

block1 <- questionIdNames$C
block2 <- c(questionIdNames$I, questionIdNames$RFQ)
block3 <- questionIdNames$REI
block4 <- c(questionIdNames$MR, questionIdNames$EPQ)
block5 <- questionIdNames$L
block6 <- questionIdNames$DPES
block7 <- c(questionIdNames$DIT, questionIdNames$RAND_DIT)
block8 <- c(questionIdNames$MELS, questionIdNames$MOPS)
block9 <- questionIdNames$MFSS
block10 <- questionIdNames$MI
block11 <- questionIdNames$CQR
block12 <- questionIdNames$IS
block13 <- questionIdNames$SV
block14 <- questionIdNames$TET
block15 <- "Block15"
block16 <- questionIdNames$EVA
block17 <- "Dov_game"

blocks <- list(block1,block2,block3,block4,block5,block6,block7,block8,block9,block10,block11,block12,block13,block14,block15,block16,block17)
```

```{r clustering, warning=FALSE}
# Suppressing warnings because Loess causes problems with spms

# This block is commented out, because it should not be run as one. Commands are heavy and produce a lot of output. Choose which plots and cluster you want to examine before running commands.

#mclusters <- lapply(blocks, function (x) {
#  Mclust(MMdata_merged[x])
#})

# Printing all summaires for all clusters
#lapply(mclusters, summary, parameters=TRUE)

# Ignoring 15 and 17, since there's only one question
#clusterBlocks <- blocks[-c(15,17)]
# spm generation for inside the blocks
#lapply(clusterBlocks, function(x){
#  columns <- paste0("~", paste(x, collapse = "+"))
#  spm(as.formula(columns), MMdata_merged)
#})
```


To obtain a weighting for each block of questions

1. obtain the principal components for each block

2. keep the ones explaining 85% of the variance

3. for each variable: sum the loadings of the most important principal components, 
weighted by the variance explained.

Additionally we tested the weights for significance within each block.

```{r principal_component_analysis}
MMdata_merged.zerofill <- MMdata_merged
MMdata_merged.zerofill[ is.na( MMdata_merged ) ] <- 0
MMdata_merged.zerofill[ MMdata_merged.zerofill == -1 ] <- 0
blocks.pcs <- lapply( blocks, function( b ) princomp( MMdata_merged.zerofill[ b ] ) )

# compute weights from pc
weightsFromPc <- function( t, pc ) 
  {
    parvs <- pc$sdev / sum( pc$sdev )
    cumvs <- cumsum( parvs )
    sigCs <- cumvs < t
    if( length( parvs[ sigCs ] ) > 1 )
      return( apply( abs( parvs[ sigCs ] * pc$loadings[ ,sigCs ] ), 1, sum) )
    else
      return( sum( pc$loadings) )
  }
blocks.weights.raw <- sapply( blocks.pcs, function( pc ) weightsFromPc( 0.85, pc ) )
blocks.weights.norm <- sapply( blocks.weights.raw, function( ws ) ws / sum( ws ) )

# test weights for significance for normal or uniform distributions
# H0: data is normal
testNorm <- function( xs ) if( length( xs ) > 2 ) shapiro.test( xs )$p.value else 0
# H0: data is uniform
testUnif <- function( xs ) ks.test( xs, "punif" )$p.value
# p value of x given that xs if normally distributed
normSig <- function( x, xs ) pnorm( x, mean=mean( xs ), sd=sd( xs ) )
# p value given that x is uniformly distributed
unifSig <- function( x, xs ) x / ( max( xs ) - min( xs ) )
# test whether p lies outside center 1-alpha prob region
twoSideP <- function( alpha, p ) p >= 0 && (p < alpha / 2 || p > 1 - alpha / 2)

alpha <- 0.1

blocks.weights.norm.pnorm <- sapply( blocks.weights.norm, testNorm )
blocks.weights.norm.punif <- sapply( blocks.weights.norm, testUnif )

blocks.weights.norm.sig <- sapply( blocks.weights.norm, function( ws ) replicate( length( ws ), -1 ) )
blocks.weights.norm.sig[ blocks.weights.norm.pnorm > 1 - alpha ] <- sapply( 
  blocks.weights.norm[ blocks.weights.norm.pnorm > 1 - alpha ]
  , function( xs ) sapply( xs, function( x ) normSig( x, xs ) )
  )

blocks.weights.norm.df <- as.data.frame( melt( blocks.weights.norm ) )
blocks.weights.norm.df$name <- unlist( blocks )
blocks.weights.norm.df$sig <- sapply( melt( blocks.weights.norm.sig )$value
                                      , function( pval ) twoSideP( alpha=alpha, pval ) )
ggplot( blocks.weights.norm.df[ blocks.weights.norm.df$L1 != c(15, 17), ]
        , aes( x=name, y=value, color=sig ) ) + 
  geom_col() + 
  facet_wrap( ~L1, ncol=4, scales="free" ) +
  theme( axis.text.x=element_text( angle=45, hjust=1 ) )
```


```{r pca_cmp_threshold}
blocks.altweights.raw <- sapply( blocks.pcs, function( pc ) weightsFromPc( 0.50, pc ) )
blocks.altweights.norm <- sapply( blocks.weights.raw, function( ws ) ws / sum( ws ) )

blocks.altweights.norm.pnorm <- sapply( blocks.altweights.norm, testNorm )
blocks.altweights.norm.punif <- sapply( blocks.altweights.norm, testUnif )

blocks.altweights.norm.sig <- sapply( blocks.altweights.norm, function( ws ) replicate( length( ws ), -1 ) )
blocks.altweights.norm.sig[ blocks.altweights.norm.pnorm > 1 - alpha ] <- sapply( 
  blocks.altweights.norm[ blocks.altweights.norm.pnorm > 1 - alpha ]
  , function( xs ) sapply( xs, function( x ) normSig( x, xs ) )
  )

blocks.altweights.norm.df <- as.data.frame( melt( blocks.weights.norm ) )
blocks.altweights.norm.df$name <- unlist( blocks )
blocks.altweights.norm.df$sig <- sapply( melt( blocks.altweights.norm.sig )$value
                                      , function( pval ) twoSideP( alpha=alpha, pval ) )

ggplot( blocks.weights.norm.df[ blocks.weights.norm.df$L1 != c(15, 17), ]
        , aes( x=name, y=value, color=sig ) ) + 
  geom_col() + 
  facet_wrap( ~L1, ncol=4, scales="free" ) +
  theme( axis.text.x=element_text( angle=45, hjust=1 ))
```


```{r kmodes_methods}
# Define methods for the clusters

get_tot_diffs <- function(x) {
  # Get the maximum difference for 15 different cluster sizes (from 2 to 16)
  kmode_res <- lapply(1:15, function(i){kmodes(x, i+1)})
  diffs <- lapply(kmode_res, function(y){sum(y$withindiff)})
  return(unlist(diffs))
}

test_kmodes_runs <- function(x, tests=5) {
  # Runs the get_max_diffs function different times to average out the random initial seed of kmodes
  all_tests <- lapply(1:tests, function(y) {get_tot_diffs(x)})
  
  # Returns dataframe with runs as rows and cluster number as columns (V[number of clusters - 1])
  return(as.data.frame(do.call(rbind, all_tests)))
}

avg_diffs_for_block <- function(x, tests = 20) {
  # Averages the cluster scores given by the previous method
  run_for_block <- test_kmodes_runs(x, tests = tests)
  print('Finished testing for one block')
  return(sapply(names(run_for_block), function(y) {mean(run_for_block[,y])}))
}
```

```{r kmodes_on_blocks_init}
multi.dim.idx <- c(1:14,16)
multi.dim.blocks <- blocks[multi.dim.idx]
```

```{r kmodes_on_blocks, eval=FALSE}
# WARNING: VERY LONG COMPUTATION! NOT WORTH RUNNING
# The results are in the object n_clust (2 blocks below)
# Actual computation of average intr-cluster difference for different k with kmodes 
all_avgs <- vector('list', length(multi.dim.blocks))
for (i in 1:length(multi.dim.blocks)){
  print(paste0(c('Iteration ', i), collapse = ''))
  
  all_avgs[[i]] <- avg_diffs_for_block(MMdata_merged[,multi.dim.blocks[[i]]], tests = 8)
}


```

```{r print_kmodes, eval=FALSE}
for (i in c(1:11,13,14,16)){
  print(paste0(c('Block ', i), collapse=''))
  plot(all_avgs[[i]])
}
```

```{r}
# For block 2, 13 and 16 no proper value
# Same order as multi dim blocks
n_clust <- c(6, 4, 5, 6, 5, 6, 7, 7, 6, 6, 7, 8, 5, 8, 9)
clust_obj <- vector('list', length(n_clust))

# Get the cluster objects for each block
for (i in 1:length(multi.dim.blocks)){
  clust_obj[[i]] <- kmodes(MMdata_merged[,multi.dim.blocks[[i]]], n_clust[i])
}

clust_df <- data.frame(block1=clust_obj[[1]]$cluster)
for (i in 2:length(multi.dim.blocks)){
  clust_df <- cbind(clust_df, clust_obj[[i]]$cluster)
}
colnames(clust_df) <- paste0('block',multi.dim.idx)
```

```{r, clust_transition_function}
# E.g. create.intersect.df('block1', 'block12', clust_df)
# Given names of 2 columns as string (e.g. block names), a dataframe with cluster values, create heatplot and return matrix
create.intersect.df <- function(x_name,y_name,data,norm_first=TRUE, return_mat=FALSE){
  idx <- data[,x_name]
  idy <- data[,y_name]
  
  # Get the clusters
  clust_x <- lapply(1:max(idx), function(i) which(idx == i))
  clust_y <- lapply(1:max(idy), function(i) which(idy == i))
  
  # Create the matrix with transitions
  mat.res <- lapply(clust_x, function(i) lapply(clust_y, function(j)length(intersect(i,j))))
  mat.res <- t(matrix(unlist(mat.res), nrow = max(idy), ncol = max(idx)))
  
  if (norm_first==TRUE) {
    mat.res <- t(apply(mat.res, 1, function(x) x/sum(x)))
  }
    
  p <- ggplot(melt(mat.res), aes(x=Var1, y=Var2, fill=value)) + geom_tile()# + labs(fill='Intersecting', x=paste0(c('from', x_name), collapse = ' '), y=paste0(c('to', y_name), collapse = ' ')) + ggtitle(paste0(c('Transitions from', x_name, 'to', y_name), collapse = ' ')) + geom_text(aes(label=round(value, 3)))
  
  if (return_mat)
    return(mat.res)
  
  return(p)
}
```

```{r transition_graph_list}
block.names <- c("block1", "block2", "block3", "block4", "block5", "block6", "block7", "block8", "block9", "block10", "block11", "block12", "block13", "block14", "block16")

# The list with all transition graphs
graph_list <- vector('list', length(block.names)^2)

count <- 1
for (i in 1:length(block.names)){
  for (j in 1:length(block.names)){
    name_1 <- block.names[i]
    name_2 <- block.names[j]
    
    graph_list[[count]] <- create.intersect.df(name_1, name_2, clust_df)
    count <- count + 1
  }
}

```

```{r}
# Sounds good, doesn't work [Try it out, it takes 20 second max]
# multiplot(plotlist = graph_list, layout = matrix(1:225, nrow = 15, ncol = 15))
```

```{r all_var_kmodes}
all_var_clust_4 <- kmodes(MMdata_merged[], 4)
```

